module BuildManager where

import Prelude

import Control.Callback (CALLBACK)
import Control.Monad.Eff (Eff)
import Control.Monad.Eff.Now (NOW)
import Control.Monad.Task as Task
import Data.Array ((:))
import Data.Array as Array
import Data.Array.Extra as Array
import Data.Blob (BLOB)
import Data.Foreign as Foreign
import Data.Foreign.Class (class Foreignable)
import Data.Foreign.Class as Foreign
import Data.Maybe (Maybe(..))
import Data.String as String
import Elm.Compiler (COMPILER)
import Elm.Compiler.Error as Error
import Elm.Compiler.Module.Name.Raw (Raw)
import Elm.Compiler.Version as Compiler
import Elm.Package.Name (Name)
import Elm.Package.Paths as Path
import Ellie.SourceLoader as SourceLoader
import System.FileSystem (FILESYSTEM, FilePath, (</>))
import System.Http (HTTP)
import TheMasterPlan.CanonicalModule (CanonicalModule(..))


outputFilePath :: FilePath
outputFilePath =
  "/build.js"


artifactDirectory :: FilePath
artifactDirectory =
  Path.stuffDirectory </> "build-artifacts" </> (show Compiler.version)


type TopLevelEffect =
  ∀ e
  . Eff
    ( avar :: Task.AVAR
    , http :: HTTP
    , fileSystem :: FILESYSTEM
    , now :: NOW
    , compiler :: COMPILER
    , callback :: CALLBACK
    , blob :: BLOB
    | e
    )
    Unit


type Task a =
  ∀ e
  . Task.Task
    ( avar :: Task.AVAR
    , http :: HTTP
    , fileSystem :: FILESYSTEM
    , now :: NOW
    , compiler :: COMPILER
    , callback :: CALLBACK
    , blob :: BLOB
    | e
    )
    Error
    a


data Error
  = CompilerInstallationError SourceLoader.Error
  | CompilerErrors FilePath String (Array Error.Error)
  | CorruptedArtifact FilePath
  | Cycle (Array CanonicalModule)
  | PackageProblem String
  | MissingPackage Name
  | ModuleNotFound Raw (Maybe Raw)
  | ModuleDuplicates
    { name :: Raw
    , parent :: Maybe Raw
    , local :: Array FilePath
    , foreign :: Array Name
    }
  | ModuleName
    { path :: FilePath
    , expectedName :: Raw
    , actualName :: Raw
    }
  | ImpossibleError String
  | CompilerCrash
    { name :: Raw
    , source :: String
    , message :: String
    }

instance showError :: Show Error where
  show err =
    case err of
      CompilerInstallationError error ->
        "Error downloading and installing the Elm compiler. I ran into a problem in the source loader.\n\n"
          <> show error
      
      ImpossibleError message ->
        "The Ellie build manager crashed on a bug. This is an issue with Ellie and not a result of any problem with your code. Here's what happened: " <> message

      CompilerCrash { name, source, message } ->
        "The compiler crashed while compiling " <> show name <> ". Here's what the compiler said about the crash: " <> message

      CompilerErrors path source errors ->
        "CompilerErrors should never be rendered to a string"

      CorruptedArtifact filePath ->
        "Error reading build artifact "
          <> filePath
          <> ". The file was generated by a previous build and may be outdated or corrupt. Clear your elm-stuff and try again."

      Cycle moduleCycle ->
        "Your dependencies form a cycle:\n\n"
          <> drawCycle moduleCycle
          <> "\nYou may need to move some values to a new module to get rid of the cycle."

      PackageProblem msg ->
        msg

      MissingPackage name ->
        "Could not find package "
          <> show name
          <> ".\n\nMaybe your elm-stuff/ directory has been corrupted? You can usually fix stuff like this by deleting elm-stuff/ and rebuilding your project."

      ModuleNotFound name maybeParent ->
        "I cannot find module '"
          <> show name
          <> "'. "
          <> toContext maybeParent
          <> " Potential problems could be:\n"
          <> "- Misspelled the module name\n"
          <> "- Need to add a new dependency in **Packages**"

      ModuleDuplicates { name, parent: maybeParent, local: filePaths, foreign: pkgs } ->
        let
          packages = map ("package " <> _) (map show pkgs)
          paths = map ("directory " <> _) filePaths
        in
          "I found multiple modules named '"
            <> show name
            <> "'. "
            <> toContext maybeParent
            <> " Modules with that name were found in the following locations:\n\n"
            <> String.joinWith "" (map (\s -> "    " <> s <> "\n") (paths <> packages))

      ModuleName { path, expectedName: nameFromPath, actualName: nameFromSource } ->
        "The module name is messed up for "
          <> path
          <> ".\n    According to the file's name it should be "
          <> show nameFromPath
          <> "\n    According to the source code it should be "
          <> show nameFromSource
          <> "\n\nWhich is it?"


drawCycle :: Array CanonicalModule -> String
drawCycle modules =
  let
    topLine =
      "┌─────┐"

    line (CanonicalModule { name }) =
      "│    " <> show name

    midLine =
      "│     ↓"

    bottomLine =
      "└─────┘"
  in
    String.joinWith "\n"
      (topLine : Array.intersperse midLine (map line modules) <> [ bottomLine ])


toContext :: Maybe Raw -> String
toContext maybeParent =
  case maybeParent of
    Nothing -> "This module is demanded in elm-package.json."
    Just parent -> "Module '" <> show parent <> "' is trying to import it."
